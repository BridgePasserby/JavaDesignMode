享元模式
Flyweight Pattern
1.定义
Use sharing to support large numbers of fine-grained objects efficiently.
使用共享对象可有效地支持大量得细粒度得对象。
关键点：细粒度的对象、共享对象

共享对象分为两部分：
内部状态：是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变，可以作为一个对象的动态附加信息，属于可共享
的部分。一般是对象池（Map中的key）的一个标记，通过该标记来获取共享对象。

外部状态：是对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。

3.单纯享元模式角色
抽象享元角色：此角色是所有具体享元类的超类，为这些类规定出需要实现的公共接口。
具体享元角色：实现抽象享元角色所规定的接口，如果有内部状态的话，必须负责为内部状态提共存储空间。
享元工厂角色：本角色负责创建和管理享元角色，如果有符合要求的享元对象则复用，没有则创建。
客户端角色：本角色需要维护一个对所有享元对象的引用，需要自行存储所有享元对象的外部状态

4.优缺点
优点：减少应用程序创建的对象
缺点：使系统更加复杂

5.适用场景
有大量类似对象
对象耗费大量的内存
对象状态大部分可以外部化
对象按照内部状态分为很多组，把外部状态从对象中剔除时，每一组对象都可以仅用一个对象代替
软件系统不依赖于这些对象的身份，即这些对象可以是不可分辨的





注意：享元模式只注重单一结果，可以理解为享元角色是一次性的。http://www.runoob.com/design-pattern/flyweight-pattern.html

享元模式，换句话说就是共享对象，在某些对象需要重复创建，且最终只需要得到单一结果的情况下使用。因为此种模式是利用先前创建
的已有对象，通过某种规则去判断当前所需对象是否可以利用原有对象做相应修改后得到想要的效果，如以上教程的实例，创建了20个不
同效果的圆，但相同颜色的圆只需要创建一次便可，相同颜色的只需要引用原有对象，改变其坐标值便可。此种模式下，同一颜色的圆虽
然位置不同，但其地址都是同一个，所以说此模式适用于结果注重单一结果的情况。

举一个简单例子，一个游戏中有不同的英雄角色，同一类型的角色也有不同属性的英雄，如刺客类型的英雄有很多个，按此种模式设计，
利用英雄所属类型去引用原有同一类型的英雄实例，然后对其相应属性进行修改，便可得到最终想得到的最新英雄；比如说你创建了第一
个刺客型英雄，然后需要设计第二个刺客型英雄，你利用第一个英雄改变属性得到第二个刺客英雄，最新的刺客英雄是诞生了，但第一个
刺客英雄的属性也随之变得与第二个相同，这种情况显然是不可以的。
